== DevOps Scenario

=== Licensing
We have selected the link:https://opensource.org/licenses/MIT[MIT License] for this project due to its highly permissive terms. This license allows for unrestricted use, modification, and distribution of the software, with minimal limitations. The MIT License provides the flexibility needed for both individual contributors and corporate entities to utilize our software while maintaining appropriate legal protections.

=== Versioning
We have adopted the Semantic Versioning (SemVer) scheme for versioning our software. SemVer consists of three numbers separated by periods: MAJOR.MINOR.PATCH. The MAJOR version is incremented for incompatible changes, the MINOR version is incremented for backward-compatible changes, and the PATCH version is incremented for backward-compatible bug fixes.

To manage the process, we decided to use the link:https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin[Git Sensitive Semantic Versioning Gradle Plugin], configured with the link:https://github.com/AndreaBrighi/conventional-commit-strategy-for-git-sensitive-semantic-versioning-gradle-plugin[Conventional Commit Strategy for Git Sensitive Semantic Versioning Gradle Plugin]. This approach allowed us to maintain a consistent versioning strategy across the project, and to automate the versioning process based on the commit messages.

The software is released via CI through link:https://github.com/semantic-release/semantic-release[semantic-release] that automatically determines the next version number based on the commit messages and releases the software on GitHub.

=== Branch Management
We implemented a structured branching strategy for this project to maintain code quality and streamline development workflows.

==== Branch Organization
Our system used two primary branches:

*main*: Contains production-ready code, updated at project milestones

*develop*: Collects all updates and ongoing development work

For feature development, we created separate branches that merged via pull requests into develop upon completion.

==== Merge Strategy
All merges to the develop branch followed a strict protocol:

* Only pull requests allowed for merging
* Rebase the feature branch onto develop before merging
* Merge strategy enforced (no merge commits)
* Linear history maintained throughout
* No primary branches deleted after successful merge

==== Protection Rules
Through branch rulesets, we enforced several key protections for the primary branches:

* Restrict deletions
* Require signed commits
* Require a pull request before merging, with merge option not allowed
* Block force pushes
* Pull requests can be closed only when the automated tests and linter checks are successful

=== Git Hooks

We have configured Git hooks using link:https://github.com/typicode/husky[Husky] to automate and enforce certain checks before commits and pushes. Husky allows us to easily manage Git hooks and ensure that our codebase maintains high standards.

The configuration includes the following hooks:

* pre-commit
* commit-msg

The pre-commit hook runs before committing, allowing code checks (e.g., linters or formatters). The commit-msg hook runs after the commit message is entered, enforcing message format or content rules.

The configuration is different between Kotlin and Typescript projects, since they use different tools for code quality checks.

(Code for Kotlin Projects - commit-msg)
[source, shell]
----
./gradlew ktlintCheck
npx --no-install commitlint --edit $1
----

(Code for Typescript Projects - commit-msg)
[source, shell]
----
npx --no-install commitlint --edit $1
----

(Code for Kotlin Projects - pre-commit)
[source, shell]
----
./gradlew ktLintFormat
----

(Code for Typescript Projects - pre-commit)
[source, shell]
----
npx lint-staged
----

Templates

=== Build Automation

=== Continuous Integration

At the purpose of making the project more reliable and maintainable, we have implemented various actions with GitHub Actions. The main actions are:

* Release Workflow
* Delete Branch on Rebase
* PR Test Pipeline
* Release

==== Release
This workflow automates the release process and is triggered by pushes to the main branch. It consists of a single job that:

* Checks out the repository with full history to access all tags
* Sets up Node.js environment
* Installs project dependencies
* Runs semantic-release to determine if a release is necessary based on commit messages

If semantic-release determines a release is needed, it automatically:

* Creates a new version based on commit conventions
* Generates release notes
* Creates a GitHub release
* Tags the repository

The release is done and signed by the CryptoMonitorCI-Bot.

==== Release Workflow
This workflow is triggered by a published release. It consists of three main jobs:

* Build and push Docker images:
** Checks out the repository
** Logs into GitHub Container Registry (GHCR)
** Sets up Docker Buildx for multi-platform builds
** Builds and pushes Docker images with appropriate tags
** Verifies the pushed image

* Build documentation:
** Generates Dokka HTML documentation
** Packages documentation files
** Uploads as workflow artifact

* Deploy documentation:
** Downloads the documentation artifact
** Switches to dokkaDoc branch
** Updates documentation files
** Signs and pushes changes with GPG key as CryptoMonitorCI-Bot

==== Delete Branch on Rebase
This workflow automatically removes branches after they have been successfully merged via pull requests. It doesn't delete protected branches like Main or Develop due to branch rulesets. The workflow:

* Triggers on pull request closure
* Verifies the pull request was merged
* Checks if the branch is not the default branch
* Attempts to delete the branch via GitHub API
* Handles potential errors from branch protection rules

==== PR Test Pipeline
This workflow runs automated checks on every pull request (creation, update, or reopening).  Due to branch protection rules, both jobs must complete successfully before the pull request can be merged.

For Kotlin projects:

* *Test job*:
** Checks out the code
** Sets up Java environment
** Configures Gradle caching
** Executes the test suite

* *Code quality job*:
** Runs Detekt static code analysis
** Posts analysis results as PR comments
** Maintains persistent feedback through sticky comments

For TypeScript projects:

* *Test job*:
** Runs Jest test suite
** Checks test coverage thresholds
** Reports test results

* *Code quality job*:
** Runs ESLint static analysis
** Checks TypeScript compilation
** Posts analysis results as PR comments
** Maintains persistent feedback through sticky comments

=== Shell Scripts
We developed various shell scripts to automatize and help our work to develop this microservice application.
The scripts are:

==== Docker Service Management Scripts

* *Service Rebuild Script*: Rebuilds all microservices except MongoDB and safely restarts MongoDB without stopping it. This preserves database state during development while allowing updates to other services.

* *Service Stop Script*: A simple utility that stops all running Docker services in our environment using the docker-compose configuration.

==== Repository Management Scripts

* *Multi-Repository Update Script*: Automates the maintenance of our multiple Git repositories by checking out the develop branch in each project directory and pulling the latest changes. The script provides error handling and reports the success or failure of each repository update operation.

These scripts significantly improved our development workflow by automating repetitive tasks, ensuring consistent development environments, and simplifying the management of our microservice architecture.


=== Containerization

Containerization, facilitated by Docker, plays a crucial role in efficiently isolating and distributing applications. Docker containers encapsulate everything needed to run an application, ensuring consistency across various environments. This approach simplifies distribution, versioning, and dependency management, enhancing the overall portability of applications.

In our microservice architecture, each microservice is containerized with its own Dockerfile, enabling independent deployment and scaling. This modular approach allows for isolated development, testing, and production environments while maintaining consistency across the development lifecycle.

==== Docker Configuration

We maintain separate Dockerfile configurations for our TypeScript and Kotlin backends, as well as our Vue.js frontend, to accommodate their different runtime requirements:

===== TypeScript Backend Dockerfile

For TypeScript microservices, we use a multi-stage build process that optimizes the final image size while maintaining all necessary dependencies. 

We leverage build automation through Gradle to standardize the build process, manage dependencies, and ensure consistent builds
across environments:
[source, dockerfile]
----
FROM gradle:8.12.1-jdk-alpine AS build
WORKDIR /usr/src/app

RUN apk add --update --no-cache curl nodejs npm

RUN java -version && gradle --version && node -v && npm -v

COPY app/build.gradle.kts settings.gradle.kts ./app/
COPY gradle ./app/gradle
COPY ./gradlew ./gradlew.bat ./app/

COPY . .

RUN gradle build
RUN gradle installProdDependencies

FROM node:22-alpine AS runtime
WORKDIR /app
RUN apk add --update --no-cache curl

COPY --from=build /usr/src/app/app/node_modules ./node_modules
COPY --from=build /usr/src/app/app/dist ./dist
COPY --from=build /usr/src/app/app/package.json ./

EXPOSE 3000

CMD ["npm", "run", "start"]
----

===== Kotlin Backend Dockerfile

For Kotlin microservices, we leverage the Gradle build system and JVM optimization techniques:

[source, dockerfile]
----
FROM gradle:8.12-jdk21 AS build

COPY app/build.gradle.kts settings.gradle.kts gradle.properties ./
RUN mkdir -p gradle
COPY gradle/libs.versions.toml gradle/
COPY app/src src

RUN --mount=type=cache,target=/home/gradle/.gradle/caches gradle jar --no-daemon --parallel --build-cache

FROM openjdk:21-jdk-slim

RUN apt-get update && apt-get install -y curl

WORKDIR /app

COPY --from=build /home/gradle/build/libs/app.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
----

===== Vue.js Frontend Dockerfile

For our Vue.js frontend application, we use a multi-stage build that compiles the application and serves it via Nginx:

[source, dockerfile]
----
FROM node:22.13-alpine AS build
WORKDIR /app
COPY app/package*.json ./
RUN npm install
COPY app/ .
RUN npm run build

FROM nginx:stable as prod-stage
COPY --from=build /app/dist /usr/share/nginx/html
COPY ./entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
EXPOSE 80
COPY ./nginx.conf /etc/nginx/conf.d/nginx.conf.template
ENTRYPOINT ["/entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]
----

The entrypoint.sh script is crucial for dynamically configuring Nginx with environment variables, allowing the frontend to communicate with various microservices:

[source, shell]
----
#!/bin/sh

envsubst '\
    \${AUTHENTICATION_SERVICE_NAME} \${AUTHENTICATION_SERVICE_PORT} \
    ${CRYPTOMARKET_SERVICE_NAME} \${CRYPTOMARKET_SERVICE_PORT}
    \${USER_MANAGEMENT_SERVICE_NAME} \${USER_MANAGEMENT_SERVICE_PORT}
    \${EVENT_DISPATCHER_SERVICE_NAME} \${EVENT_DISPATCHER_SERVICE_PORT}
    \${NOTIFICATION_SERVICE_NAME} \${NOTIFICATION_SERVICE_PORT}'< /etc/nginx/conf.d/nginx.conf.template > /etc/nginx/nginx.conf

# Start Nginx
exec "$@"
----

This script uses `envsubst` to replace environment variable placeholders in the Nginx configuration template with actual values at container startup time, enabling flexible service discovery in our microservices architecture.

Each Docker image is automatically built, tagged, and published to GitHub Container Registry through our CI/CD pipelines, ensuring that the latest version is always available for deployment.