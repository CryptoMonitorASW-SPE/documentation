== DevOps Scenario

=== Licensing
We have selected the link:https://opensource.org/licenses/MIT[MIT License] for this project due to its highly permissive terms. This license allows for unrestricted use, modification, and distribution of the software, with minimal limitations. The MIT License provides the flexibility needed for both individual contributors and corporate entities to utilize our software while maintaining appropriate legal protections.

=== Versioning
We have adopted the Semantic Versioning (SemVer) scheme for versioning our software. SemVer consists of three numbers separated by periods: MAJOR.MINOR.PATCH. The MAJOR version is incremented for incompatible changes, the MINOR version is incremented for backward-compatible changes, and the PATCH version is incremented for backward-compatible bug fixes.

To manage the process, we decided to use the link:https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin[Git Sensitive Semantic Versioning Gradle Plugin], configured with the link:https://github.com/AndreaBrighi/conventional-commit-strategy-for-git-sensitive-semantic-versioning-gradle-plugin[Conventional Commit Strategy for Git Sensitive Semantic Versioning Gradle Plugin]. This approach allowed us to maintain a consistent versioning strategy across the project, and to automate the versioning process based on the commit messages.

The software is released via CI through link:https://github.com/semantic-release/semantic-release[semantic-release] that automatically determines the next version number based on the commit messages and releases the software on GitHub.

=== Branch Management
We implemented a structured branching strategy for this project to maintain code quality and streamline development workflows.

==== Branch Organization
Our system used two primary branches:

*main*: Contains production-ready code, updated at project milestones

*develop*: Collects all updates and ongoing development work

For feature development, we created separate branches that merged via pull requests into develop upon completion.

==== Merge Strategy
All merges to the develop branch followed a strict protocol:

* Only pull requests allowed for merging
* Rebase the feature branch onto develop before merging
* Merge strategy enforced (no merge commits)
* Linear history maintained throughout
* No primary branches deleted after successful merge

==== Protection Rules
Through branch rulesets, we enforced several key protections for the primary branches:

* Restrict deletions
* Require signed commits
* Require a pull request before merging, with merge option not allowed
* Block force pushes
* Pull requests can be closed only when the automated tests and linter checks are successful

=== Git Hooks

We have configured Git hooks using link:https://github.com/typicode/husky[Husky] to automate and enforce certain checks before commits and pushes. Husky allows us to easily manage Git hooks and ensure that our codebase maintains high standards.

The configuration includes the following hooks:

* pre-commit
* commit-msg

The pre-commit hook runs before committing, allowing code checks (e.g., linters or formatters). The commit-msg hook runs after the commit message is entered, enforcing message format or content rules.

The configuration is different between Kotlin and Typescript projects, since they use different tools for code quality checks.

(Code for Kotlin Projects - commit-msg)
[source, shell]
----
./gradlew ktlintCheck
npx --no-install commitlint --edit $1
----

(Code for Typescript Projects - commit-msg)
[source, shell]
----
npx --no-install commitlint --edit $1
----

(Code for Kotlin Projects - pre-commit)
[source, shell]
----
./gradlew ktLintFormat
----

(Code for Typescript Projects - pre-commit)
[source, shell]
----
npx lint-staged
----



Templates

=== Build Automation

=== Continuous Integration

At the purpose of making the project more reliable and maintainable, we have implemented various actions with GitHub Actions. The main actions are:

* Release Workflow
* Delete Branch on Rebase
* PR Test Pipeline
* Release

==== Release
This workflow automates the release process and is triggered by pushes to the main branch. It consists of a single job that:

* Checks out the repository with full history to access all tags
* Sets up Node.js environment
* Installs project dependencies
* Runs semantic-release to determine if a release is necessary based on commit messages

If semantic-release determines a release is needed, it automatically:

* Creates a new version based on commit conventions
* Generates release notes
* Creates a GitHub release
* Tags the repository

The release is done and signed by the CryptoMonitorCI-Bot user.

==== Release Workflow
This workflow is triggered by a published release. It consists of three main jobs:

* Build and push Docker images:
** Checks out the repository
** Logs into GitHub Container Registry (GHCR)
** Sets up Docker Buildx for multi-platform builds
** Builds and pushes Docker images with appropriate tags
** Verifies the pushed image

* Build documentation:
** Generates Dokka HTML documentation
** Packages documentation files
** Uploads as workflow artifact

* Deploy documentation:
** Downloads the documentation artifact
** Switches to dokkaDoc branch
** Updates documentation files
** Signs and pushes changes with GPG key as CryptoMonitorCI-Bot

==== Delete Branch on Rebase
This workflow automatically removes branches after they have been successfully merged via pull requests. It doesn't delete protected branches like Main or Develop due to branch rulesets. The workflow:

* Triggers on pull request closure
* Verifies the pull request was merged
* Checks if the branch is not the default branch
* Attempts to delete the branch via GitHub API
* Handles potential errors from branch protection rules

==== PR Test Pipeline
This workflow runs automated checks on every pull request (creation, update, or reopening).  Due to branch protection rules, both jobs must complete successfully before the pull request can be merged.

For Kotlin projects:

* *Test job*:
** Checks out the code
** Sets up Java environment
** Configures Gradle caching
** Executes the test suite

* *Code quality job*:
** Runs Detekt static code analysis
** Posts analysis results as PR comments
** Maintains persistent feedback through sticky comments

For TypeScript projects:

* *Test job*:
** Runs Jest test suite
** Checks test coverage thresholds
** Reports test results

* *Code quality job*:
** Runs ESLint static analysis
** Checks TypeScript compilation
** Posts analysis results as PR comments
** Maintains persistent feedback through sticky comments

=== Containerization

