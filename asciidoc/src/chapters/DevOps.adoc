== DevOps Scenario

=== Licensing
We have selected the link:https://opensource.org/licenses/MIT[MIT License] for this project due to its highly permissive terms. This license allows for unrestricted use, modification, and distribution of the software, with minimal limitations. The MIT License provides the flexibility needed for both individual contributors and corporate entities to utilize our software while maintaining appropriate legal protections.

=== Versioning
We have adopted the Semantic Versioning (SemVer) scheme for versioning our software. SemVer consists of three numbers separated by periods: MAJOR.MINOR.PATCH. The MAJOR version is incremented for incompatible changes, the MINOR version is incremented for backward-compatible changes, and the PATCH version is incremented for backward-compatible bug fixes.

To manage the process, we decided to use the link:https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin[Git Sensitive Semantic Versioning Gradle Plugin], configured with the link:https://github.com/AndreaBrighi/conventional-commit-strategy-for-git-sensitive-semantic-versioning-gradle-plugin[Conventional Commit Strategy for Git Sensitive Semantic Versioning Gradle Plugin]. This approach allowed us to maintain a consistent versioning strategy across the project, and to automate the versioning process based on the commit messages.

The software is released via CI through link:https://github.com/semantic-release/semantic-release[semantic-release] that automatically determines the next version number based on the commit messages and releases the software on GitHub.

=== Branch Management
We implemented a structured branching strategy for this project to maintain code quality and streamline development workflows.

==== Branch Organization
Our system used two primary branches:

*main*: Contains production-ready code, updated at project milestones

*develop*: Collects all updates and ongoing development work

For feature development, we created separate branches that merged via pull requests into develop upon completion.

==== Merge Strategy
All merges to the develop branch followed a strict protocol:

* Only pull requests allowed for merging
* Rebase the feature branch onto develop before merging
* Merge strategy enforced (no merge commits)
* Linear history maintained throughout
* No primary branches deleted after successful merge

==== Protection Rules
Through branch rulesets, we enforced several key protections for the primary branches:

* Restrict deletions
* Require signed commits
* Require a pull request before merging, with merge option not allowed
* Block force pushes
* Pull requests can be closed only when the automated tests and linter checks are successful

=== Git Hooks

We have configured Git hooks using link:https://github.com/typicode/husky[Husky] to automate and enforce certain checks before commits and pushes. Husky allows us to easily manage Git hooks and ensure that our codebase maintains high standards.

The configuration includes the following hooks:

* pre-commit
* commit-msg

The pre-commit hook runs before committing, allowing code checks (e.g., linters or formatters). The commit-msg hook runs after the commit message is entered, enforcing message format or content rules.

The configuration is different between Kotlin and Typescript projects, since they use different tools for code quality checks.

(Code for Kotlin Projects - commit-msg)
[source, shell]
----
./gradlew ktlintCheck
npx --no-install commitlint --edit $1
----

(Code for Typescript Projects - commit-msg)
[source, shell]
----
npx --no-install commitlint --edit $1
----

(Code for Kotlin Projects - pre-commit)
[source, shell]
----
./gradlew ktLintFormat
----

(Code for Typescript Projects - pre-commit)
[source, shell]
----
npx lint-staged
----



Templates

=== Build Automation

=== Continuous Integration

Code quality, Testing, Release, Documentation, GHCR Images

=== Containerization

